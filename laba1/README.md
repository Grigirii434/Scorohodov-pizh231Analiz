
# Лабораторная работа 01: Введение в алгоритмы. Сложность. Поиск

## Цель работы
Освоить понятие вычислительной сложности алгоритмов.  
Получить практические навыки реализации и анализа линейного и бинарного поиска.  
Научиться экспериментально подтверждать теоретические оценки сложности **O(n)** и **O(log n)**.

---

## Теория

- **Сложность алгоритма** - Характеризует количество ресурсов (времени и памяти), необходимых
 алгоритму для обработки входных данных объема n
- **Асимптотический анализ:** - Анализ поведения алгоритма при стремлении n к бесконечности.
 Позволяет абстрагироваться от констант и аппаратных особенностей.
- **O-нотация («О-большое»)** - Верхняя асимптотическая оценка роста функции. Определяет
 наихудший сценарий работы алгоритма.
- **Линейный поиск (Linear Search)** - Последовательный перебор всех элементов массива. Сложность: O(n)
- **Бинарный поиск (Binary Search)** -Поиск в отсортированном массиве путем многократного
 деления интервала поиска пополам. Сложность: O(log n). Требует предварительной сортировки
 (O(n log n)).

### Линейный поиск
- Перебор элементов массива последовательно.  
- В худшем случае проверяет все `n` элементов.  
- Сложность: **O(n)**.  

### Бинарный поиск
- Работает только на отсортированном массиве.  
- На каждом шаге делит интервал поиска пополам.  
- Количество шагов пропорционально `log₂(n)`.  
- Сложность: **O(log n)**.  
- Дополнительно: сортировка массива перед поиском имеет сложность **O(n log n)**.

---

## Практика

### Задание
1. Реализовать функции:
   - `linear_search(arr, target)`  
   - `binary_search(arr, target)`  
2. Добавить комментарии с оценкой сложности каждой строки.  
3. Провести замеры времени выполнения для разных размеров массива.  
4. Построить графики зависимости времени от размера массива.  
5. Сравнить теоретическую и практическую сложность.  

### Подготовка данных
- Сгенерированы отсортированные массивы: `[1000, 5000, 10000, 50000, 100000, 500000]`.  
- Для поиска выбран элемент: **последний** (худший случай).  

### Характеристики ПК
- Процессор: AMD Ryzen 5 5600G @ 4.30GHz
- Оперативная память: 16 GB DDR4
- ОС: Windows 11
- Python: 3.13


---

## Результаты замеров

Таблица (время в миллисекундах, усреднение по 10 запускам):

| Размер (n) | Линейный (мс) | Бинарный (мс) |
|------------|----------------|----------------|
| 1 000      | 0.0130         | 0.0009         |
| 5 000      | 0.0832         | 0.0013         |
| 10 000     | 0.1992         | 0.0010         |
| 50 000     | 2.0518         | 0.0015         |
| 100 000    | 0.3474         | 0.0016         |
| 500 000    | 22.0347        | 0.0018         |
| 1 000 000  | 69.0726        | 0.0019         |


## Графики

### 1. В линейном масштабе и логарифмическом масштабах
![Сравнение линейного и бинарного поиска](search_comparison.png)

---

## Анализ результатов

1. Теоретически:
   - Линейный поиск: **O(n)**.  
   - Бинарный поиск: **O(log n)**.  
2. Эксперименты подтвердили:
   - Время линейного поиска растёт **пропорционально n**.  
   - Время бинарного поиска растёт максимально медленно, **по 0.0001 мс за каждый поиск по мере увеличения размера (n)**. 
3. Разница особенно заметна на больших массивах: бинарный поиск работает в сотни раз быстрее.  

---
## Контрольные вопросы
1. Что такое асимптотическая сложность алгоритма и зачем она нужна?
Асимптотическая сложность описывает поведение временной или пространственной эффективности алгоритма при стремлении размера входных данных к бесконечности. Она позволяет оценить, насколько быстро увеличивается количество операций, необходимых для решения задачи, в зависимости от роста объема данных. Основная цель такого анализа — сравнить эффективность разных подходов независимо от конкретных реализаций и аппаратных особенностей компьютеров.Наиболее распространенной формой записи асимптотической сложности является обозначение О(большое): 
O(f(n))
O(f(n)), где f(n)
f(n) показывает зависимость числа операций от количества элементов n
n.
Зачем нужна асимптотическая оценка: Чтобы выбрать наиболее эффективный алгоритм среди возможных решений одной и той же задачи, особенно когда размер входных данных велик.
2. Разница между O(1), O(n) и O(log n):
O(1)
O(1): Постоянное время выполнения. Время выполнения не зависит от размера входных данных. Примеры:
Доступ к элементу массива по индексу (arr[i]).
Хэширование элемента в хеш-таблице (если отсутствует коллизия).
O(n)
O(n): Линейное время выполнения. Количество операций прямо пропорционально размеру входных данных. Примеры:
Поиск максимального значения в массиве.
Простой перебор всех элементов списка.
O(log⁡n)
O(logn): Логарифмическое время выполнения. Число операций растет гораздо медленнее, чем объем данных, поскольку каждая итерация уменьшает число рассматриваемых элементов примерно вдвое. Пример:
Бинарный поиск в отсортированном массиве.
3. Основное отличие линейного поиска от бинарного
Линейный поиск: Алгоритм последовательно проверяет каждый элемент коллекции, пока не найдет искомый объект или не достигнет конца последовательности. Его временная сложность — O(n)
O(n), так как в худшем случае потребуется просмотреть весь список.
Бинарный поиск: Используется только на предварительно отсортированных структурах данных. Алгоритм выбирает середину диапазона и сравнивает искомое значение с центральным элементом, сокращая область поиска наполовину на каждой итерации. Временная сложность — 
O(log⁡n)
O(logn).
Предварительное условие для бинарного поиска: Входные данные обязательно должны быть отсортированы.
4. Почему на практике время выполнения отличается от теоретического оценочного показателя O-большое?
Теоретический показатель 
O
O-сложности отражает только асимптотическое поведение при больших значениях 
n
n. Однако на практике существуют дополнительные факторы, влияющие на производительность программы:
Константа перед функцией. Например, 
O(1000∗n)
O(1000∗n) выполняется значительно дольше, чем O(n)
O(n), хотя обе имеют одинаковую асимптотику.
Аппаратные особенности. Производительность компьютера влияет на скорость исполнения инструкций.
Эффективность реализации. Один и тот же алгоритм может быть реализован разными способами, некоторые из которых эффективнее используют память или процессор.
Дополнительные операции. Реальные алгоритмы часто включают дополнительные шаги (например, сортировка перед поиском), что увеличивает общее время выполнения.
Таким образом, реальные замеры зависят не только от асимптотики, но и от многих других факторов.

5. Экспериментальное подтверждение сложности алгоритма
Чтобы проверить эмпирически, соответствует ли временная сложность алгоритма заявленной оценке (
O(n)
O(n) или O(log⁡n)
O(logn)):

План эксперимента:
Подготовьте программу, измеряющую время выполнения алгоритма на множестве входных данных разного размера.
Для каждого фиксированного размера входных данных запускайте алгоритм несколько раз и усредняйте полученные временные показатели.
Постройте график зависимости среднего времени выполнения от размера данных.
Оцените характер кривой графика:
Если график близок к прямой линии (наклон которой пропорционален количеству операций), то ваша программа имеет сложность порядка 
O(n)
O(n).
Если график демонстрирует замедление роста (график выглядит полулогарифмическим), значит ваш алгоритм работает приблизительно за 
O(log⁡n)
O(logn).
Используйте регрессию для аппроксимации полученной зависимости и проверки гипотезы о форме кривой.
Для точного подтверждения используйте методы статистического анализа (регрессия, сравнение отклонений и др.). Такой подход позволит вам убедиться, что реальный опыт подтверждает ожидаемую оценку сложности вашего алгоритма.
## Выводы
- Реализованы линейный и бинарный поиск.  
- Погрешности в замерах обусловлены многозадачностью ОС, кэшированием, работой интерпретатора Python и случайными колебаниями времени на микросекундных интервалах. Для больших массивов они не влияют на общий тренд: линейный поиск растёт пропорционально N, бинарный почти не изменяется.
- Полученные замеры подтверждают теоретическую асимптотику.  
- Бинарный поиск значительно эффективнее при больших входных данных. 
- Работа показала важность выбора алгоритма: асимптотическая разница даёт колоссальный выигрыш на практике.  
- Линейный поиск показывает линейный рост времени
- Бинарный поиск демонстрирует логарифмическую сложность
